{"mappings":"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","sources":["workspaces/utils/src/utils.js","workspaces/utils/src/parse_arguments.js"],"sourcesContent":["import debugFunc from 'debug'\nimport fs from 'fs'\n\nconst debug = debugFunc('@foo-dog:utils')\n\nfunction isSupportedFileExtension(fileExtWithDot) {\n  debug('isSupportedFileExtension(): fileExtWithDot=' + fileExtWithDot)\n  return fileExtWithDot.toLowerCase() == '.pug' || fileExtWithDot.toLowerCase() == '.foo-dog'\n}\n\nArray.prototype.peek = function () {\n  return this[this.length - 1]\n}\n\nString.prototype.removeFromEnd = function (str) {\n  return this.endsWith(str) ? this.substring(0, this.lastIndexOf(str)) : this.toString()\n}\n\nfunction exists(filename) {\n  try {\n    return (fs.accessSync(filename), true)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction directoryExists(dir) {\n  try {\n    // fs.lstatSync(destFileToWriteTo)\n    fs.accessSync(dir, fs.constants.R_OK)\n    return true\n  } catch (e) { }\n  return false\n}\n\nfunction createDirectory(dir) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\n// /**\n//  * @param process Node process (TODO: pass in arguments only)\n//  * @param printUsage function\n//  */\n// // This isn't fully flushed out yet\n// async function parseArguments(process, printUsage) {\n//   const argv = minimist(process.argv.slice(2))\n//   // debug('argv=', argv)\n\n\n  \n//   let ret = { in: {}, out: {} }\n\n//   if (argv.help || argv.h) {\n//     debug('help option detected')\n//     if (printUsage != undefined && typeof printUsage === 'function') {\n//       printUsage()\n//     }\n//     else {\n//       console.log('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n//     }\n//     process.exit()\n//   } else if (argv._.length == 0) {\n//     debug('no arguments - using stdin and stdout')\n//     ret = { \n//       in: { \n//         name: 'stdin', \n//         createStream: () => process.stdin, \n//         isDir: () => false \n//       }, \n//       out: { \n//         name: 'stdout', \n//         createStream: () => process.stdout, \n//         isDir: () => false\n//       }\n//     }\n//   } else if (argv._.length == 1) {\n//     debug('one argument - reading file and piping to stdout')\n//     try {\n//       fs.accessSync(argv._[0], fs.constants.R_OK)\n//     } catch (e) {\n//       throw new Error(`Could not ${e.syscall} \"${e.path}\"`)\n//     }\n\n//     // debug('creating read stream for ' + argv?._[0])\n//     const resolvedIn = path.resolve(argv._[0])\n\n//     ret = {\n//       in: {\n//         name: argv._[0],\n//         createStream: () => fs.createReadStream(resolvedIn),\n//         isDir: () => fs.lstatSync(argv._[0]).isDirectory(),\n//         files: () => fs.lstatSync(resolvedIn).isDirectory() ? fs.readdirSync(resolvedIn, { withFileTypes: true }).filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1)))).map(dirrent => dirrent.name) : resolvedIn\n//       },\n//       out: { name: 'stdout', createStream: () => process.stdout, isDir: () => false },\n//       override: argv.f\n//     }\n//   } else {\n//     debug('two or more arguments')\n\n//     if (argv._[0] == '-') {\n//       debug('first argument was - - using stdin')\n//       ret.in = {\n//         name: 'stdin',\n//         createStream: () => process.stdin,\n//         isDir: () => false\n//       }\n//       debug('Reading from stdin');\n//     } else {\n//       const resolvedIn = path.resolve(argv._[0])\n//       debug(`first argument was ${argv._[0]}. Resolved is ${resolvedIn}`)\n//       try {\n//         fs.accessSync(resolvedIn, fs.constants.R_OK)\n\n//         debug('fs.readdirSync(resolvedIn)=', fs.readdirSync(resolvedIn))\n\n//         ret.in = {\n//           name: resolvedIn,\n//           createStream: () => fs.createReadStream(resolvedIn),\n//           isDir: () => fs.lstatSync(resolvedIn).isDirectory(),\n//           files: () => {\n//             if (fs.lstatSync(resolvedIn).isDirectory()) {\n//               return fs\n//                 .readdirSync(resolvedIn, { withFileTypes: true })\n//                 .filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1))))\n//                 .map(dirrent => {\n//                   debug('dirrent.name=' + dirrent.name)\n//                   debug('path.resolve(resolvedIn, dirrent.name)=' + path.resolve(resolvedIn, dirrent.name))\n//                   return path.resolve(resolvedIn, dirrent.name)\n//                 }) \n//              }\n//              else {\n//               return resolvedIn\n//              }\n//           }\n//         }\n//       } catch (e) {\n//         if (e.hasOwnProperty('syscall'))\n//           throw new Error(`Could not ${e.syscall} \"${e.path}\"`, { cause: e })\n//         else\n//           throw e;\n//       }\n//     }\n\n//     if (argv._[1] == '-') {\n//       debug('second argument was - - using stdout')\n//       ret.out = {\n//         name: 'stdout',\n//         createStream: () => process.stdout,\n//         isDir: () => false\n//       }\n//       debug('writing to stdout');\n//     } else {\n\n//       debug('argv._[1]=', argv._[1])\n//       const dest = path.resolve(argv._[1]);\n//       debug('dest=', dest)\n\n//       if (argv._[1].endsWith(path.sep)) {\n//         // handle out as directory\n        \n//         // check if the directory exists\n//         if (!directoryExists(dest)) {\n//           createDirectory(dest)\n//         }\n//         ret.out = {\n//           name: dest,\n//           createStream: () => fs.createWriteStream(dest, { flags: 'w' }),\n//           isDir: () => true\n//         }\n//       }\n//       else {\n//         // handleOutAsFile\n\n//         const destDir = path.dirname(argv._[1]);\n\n//         // check if the directory exists\n//         if (!directoryExists(destDir)) {\n//           createDirectory(destDir)\n//         }\n//         ret.out = {\n//           name: argv._[1],\n//           createStream: () => {\n//             return fs.createWriteStream(dest, { flags: 'w' })\n//           },\n//           isDir: () => false\n//         }\n\n//       }\n//     }\n//   }\n\n//   if (argv.hasOwnProperty('f')) {\n//     ret.override = argv.f\n//   }\n//   if (argv.hasOwnProperty('allow-digits-to-start-css-classes')) {\n//     ret.allowDigitToStartClassName = !!argv['allow-digits-to-start-css-classes']\n//     debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n//   } else if (argv.hasOwnProperty('allowDigitToStartClassName')) {\n//     ret.allowDigitToStartClassName = new Boolean(argv['allowDigitToStartClassName'])\n//     debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n//   }\n\n//   return ret\n// }\n\nfunction simpleProjectRootDir() {\n  const originalDir = process.cwd()\n  let notFound = true\n  while (notFound) {\n    try {\n      fs.accessSync('package.json', fs.constants.F_OK)\n      notFound = false\n    } catch (e) {\n      process.chdir('..')\n    }\n  }\n  const pkgDir = process.cwd()\n  process.chdir(originalDir)\n  return pkgDir\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  directoryExists,\n  createDirectory,\n  simpleProjectRootDir\n}","import fs from \"node:fs\";\nimport path from \"node:path\";\nimport debugFunc from \"debug\";\nimport { directoryExists, createDirectory } from \"./utils.js\"\nconst debug = debugFunc(\"@foo-dog/utils:parse_arguments\");\nconst isInTest = import.meta.url.endsWith(\"?test\");\n\n/**\n * @param process Node process (TODO: pass in arguments only)\n * @param printUsage function to print when \"-h\" or \"--help\" is a parameter\n * @param options optional and required parameters:\n *        {\n *          optional: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ],\n *          required: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ]\n *        }\n */\n// This isn't fully flushed out yet\nasync function parseArguments(processOrArgv, printUsage, options) {\n  function isNodeProcess(processOrArgv) {\n    debug(\"processOrArgv=\", processOrArgv);\n\n    return (\n      typeof processOrArgv === \"object\" &&\n      processOrArgv.hasOwnProperty(\"argv\") &&\n      processOrArgv.argv[0].startsWith(\"/\") &&\n      processOrArgv.title === \"node\"\n    );\n  }\n\n  if (options == undefined) {\n    if (printUsage !== null && typeof printUsage === \"object\") {\n      options = printUsage;\n    } else {\n      options = {};\n    }\n  }\n\n  const optionalParams = options.optional ?? [];\n  const requiredParams = options.required ?? [];\n\n  debug(\"options.required=\", options.required);\n  debug(\"requiredParams=\", requiredParams);\n\n  const ret = {};\n  let args;\n  if (isNodeProcess(processOrArgv)) {\n    ret.nodePath = processOrArgv.argv[0];\n    ret.program = processOrArgv.argv[1];\n    args = processOrArgv.argv.slice(2);\n  } else {\n    args = processOrArgv?.argv || processOrArgv;\n  }\n\n  if (args.includes(\"-h\") || args.includes(\"--help\")) {\n    printUsage();\n    if (!isInTest) {\n      process.exit(0);\n    } else {\n      return;\n    }\n  }\n\n  const internalOptions = {},\n    internalArgs = [];\n  for (let i = 0; i < args.length; i++) {\n    const element = args[i];\n    if (element === \"-\") {\n      internalArgs.push(element);\n    } else if (element.startsWith(\"--\")) {\n      const [key, val] = element.split(\"=\");\n      internalOptions[key.slice(2)] = val || true;\n    } else if (element.startsWith(\"-\")) {\n      const [key, val] = element.split(\"=\");\n      internalOptions[key.slice(1)] = val || true;\n    } else {\n      internalArgs.push(element);\n    }\n  }\n\n  if (options.hasOwnProperty('skipCreateStreamFunctions') && options.skipCreateStreamFunctions === true) {\n    if (internalArgs.length > 0) {\n      ret.args = internalArgs;\n    }\n  }\n  else {\n    const [inFilename, outFilename] = internalArgs;\n    ret.in = createInObject(inFilename);\n    ret.out = createOutObject(outFilename);\n    ret.args = internalArgs.slice(2);\n  }\n\n  if (Object.keys(internalOptions).length > 0) {\n    ret.options = internalOptions;\n  }\n\n  checkForRequiredParameters(requiredParams, ret);\n\n  return ret;\n\n  function createInObject(inFilename) {\n    const inObj = {};\n    inObj.name = inFilename ?? \"stdin\";\n    if (inObj.name === \"stdin\") {\n      inObj.createStream = () => process.stdin;\n      inObj.isDir = () => false;\n    } else {\n      const resolvedIn = path.resolve(inObj.name);\n\n      try {\n        fs.accessSync(resolvedIn, fs.constants.R_OK);\n      } catch (e) {\n        console.error(e);\n        throw new Error(`Could not ${e.syscall} \"${e.path}\"`);\n      }\n\n      inObj.createStream = () => fs.createReadStream(resolvedIn);\n      (inObj.isDir = () => fs.lstatSync(resolvedIn).isDirectory()),\n        (inObj.files = () =>\n          fs.lstatSync(resolvedIn).isDirectory()\n            ? fs\n                .readdirSync(resolvedIn, { withFileTypes: true })\n                .filter(\n                  (dirent) =>\n                    dirent.isFile() &&\n                    isSupportedFileExtension(path.extname(dirent.name.slice(1)))\n                )\n                .map((dirrent) => dirrent.name)\n            : resolvedIn);\n    }\n\n    return inObj;\n  }\n\n  function createOutObject(outFilename) {\n    const outObj = {};\n    outObj.name = outFilename ?? \"stdout\";\n    if (outObj.name === \"stdout\") {\n      outObj.createStream = () => process.stdout;\n      outObj.isDir = () => false;\n    } else {\n      const dest = path.resolve(outObj.name);\n      debug(\"dest=\", dest);\n\n      if (outObj.name.endsWith(path.sep)) {\n        // handle out as directory\n\n        // check if the directory exists\n        if (!directoryExists(dest)) {\n          createDirectory(dest);\n        }\n\n        outObj.name = dest;\n        (outObj.createStream = () =>\n          fs.createWriteStream(dest, { flags: \"w\" })),\n          (outObj.isDir = () => true);\n      } else {\n        // handleOutAsFile\n        const destDir = path.dirname(outObj.name);\n\n        // check if the directory exists\n        if (!directoryExists(destDir)) {\n          createDirectory(destDir);\n        }\n        (outObj.name = outObj.name),\n          (outObj.createStream = () => {\n            return fs.createWriteStream(dest, { flags: \"w\" });\n          }),\n          (outObj.isDir = () => false);\n      }\n    }\n    return outObj;\n  }\n\n  function checkForRequiredParameters(requiredParams, argumentsAndOptions) {\n    requiredParams.forEach((requiredParameter) => {\n      checkForRequiredParam(requiredParameter, argumentsAndOptions);\n    });\n  }\n\n  function checkForRequiredParam(requiredParameter, argumentsAndOptions) {\n    let nameAndAliases = [requiredParameter.name];\n    if (requiredParameter.aliases) {\n      nameAndAliases = nameAndAliases.concat(requiredParameter.aliases);\n    }\n\n    const argumentsHasNameOrAlias = doArgumentsOrOptionsHaveNameOrAlias(\n      nameAndAliases,\n      argumentsAndOptions\n    );\n\n    if (!argumentsHasNameOrAlias) {\n      throw new Error(\n        'Required field \"' + requiredParameter.name + '\" was not found'\n      );\n    }\n  }\n\n  function doArgumentsOrOptionsHaveNameOrAlias(\n    nameAndAliases,\n    argumentsAndOptions\n  ) {\n    return (\n      checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.args) ||\n      checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.options)\n    );\n  }\n\n  function checkCollectionForNameOrAlias(nameAndAliases, parameterCollection) {\n    let argumentsHaveNameOrAlias = false;\n    debug(\"nameAndAliases=\", nameAndAliases);\n    debug(\"parameterCollection=\", parameterCollection);\n    if (parameterCollection != undefined) {\n      if (Array.isArray(parameterCollection) && parameterCollection.length) {\n        argumentsHaveNameOrAlias = nameAndAliases.some((name) =>\n          parameterCollection.includes(name)\n        );\n      } else if (typeof parameterCollection === \"object\") {\n        argumentsHaveNameOrAlias = nameAndAliases.some((name) =>\n          parameterCollection.hasOwnProperty(name)\n        );\n      } else {\n        console.error(\n          \"Unexpected error in checkCollectionForNameOrAlias(). nameAndAliases=\",\n          nameAndAliases,\n          \", parameterCollection=\",\n          parameterCollection\n        );\n        throw new Error(\"Unexpected error (and nothing coded to handle it)\");\n      }\n    }\n    return argumentsHaveNameOrAlias;\n  }\n  // // const argv = minimist(process.argv.slice(2))\n  // // debug('argv=', argv)\n  // let ret = { in: {}, out: {} }\n\n  // if (argv.help || argv.h) {\n  //   debug('help option detected')\n  //   if (printUsage != undefined && typeof printUsage === 'function') {\n  //     printUsage()\n  //   }\n  //   else {\n  //     debug('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n  //   }\n  //   process.exit()\n  // } else if (argv._.length == 0) {\n  //   debug('no arguments - using stdin and stdout')\n  //   ret = {\n  //     in: {\n  //       name: 'stdin',\n  //       createStream: () => process.stdin,\n  //       isDir: () => false\n  //     },\n  //     out: {\n  //       name: 'stdout',\n  //       createStream: () => process.stdout,\n  //       isDir: () => false\n  //     }\n  //   }\n  // } else if (argv._.length == 1) {\n  //   debug('one argument - reading file and piping to stdout')\n  //   try {\n  //     fs.accessSync(argv._[0], fs.constants.R_OK)\n  //   } catch (e) {\n  //     throw new Error(`Could not ${e.syscall} \"${e.path}\"`)\n  //   }\n\n  //   // debug('creating read stream for ' + argv?._[0])\n  //   const resolvedIn = path.resolve(argv._[0])\n\n  //   ret = {\n  //     in: {\n  //       name: argv._[0],\n  //       createStream: () => fs.createReadStream(resolvedIn),\n  //       isDir: () => fs.lstatSync(argv._[0]).isDirectory(),\n  //       files: () => fs.lstatSync(resolvedIn).isDirectory() ? fs.readdirSync(resolvedIn, { withFileTypes: true }).filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1)))).map(dirrent => dirrent.name) : resolvedIn\n  //     },\n  //     out: { name: 'stdout', createStream: () => process.stdout, isDir: () => false },\n  //     override: argv.f\n  //   }\n  // } else {\n  //   debug('two or more arguments')\n\n  //   if (argv._[0] == '-') {\n  //     debug('first argument was - - using stdin')\n  //     ret.in = {\n  //       name: 'stdin',\n  //       createStream: () => process.stdin,\n  //       isDir: () => false\n  //     }\n  //     debug('Reading from stdin');\n  //   } else {\n  //     const resolvedIn = path.resolve(argv._[0])\n  //     debug(`first argument was ${argv._[0]}. Resolved is ${resolvedIn}`)\n  //     try {\n  //       fs.accessSync(resolvedIn, fs.constants.R_OK)\n\n  //       debug('fs.readdirSync(resolvedIn)=', fs.readdirSync(resolvedIn))\n\n  //       ret.in = {\n  //         name: resolvedIn,\n  //         createStream: () => fs.createReadStream(resolvedIn),\n  //         isDir: () => fs.lstatSync(resolvedIn).isDirectory(),\n  //         files: () => {\n  //           if (fs.lstatSync(resolvedIn).isDirectory()) {\n  //             return fs\n  //               .readdirSync(resolvedIn, { withFileTypes: true })\n  //               .filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1))))\n  //               .map(dirrent => {\n  //                 debug('dirrent.name=' + dirrent.name)\n  //                 debug('path.resolve(resolvedIn, dirrent.name)=' + path.resolve(resolvedIn, dirrent.name))\n  //                 return path.resolve(resolvedIn, dirrent.name)\n  //               })\n  //            }\n  //            else {\n  //             return resolvedIn\n  //            }\n  //         }\n  //       }\n  //     } catch (e) {\n  //       if (e.hasOwnProperty('syscall'))\n  //         throw new Error(`Could not ${e.syscall} \"${e.path}\"`, { cause: e })\n  //       else\n  //         throw e;\n  //     }\n  //   }\n\n  //   if (argv._[1] == '-') {\n  //     debug('second argument was - - using stdout')\n  //     ret.out = {\n  //       name: 'stdout',\n  //       createStream: () => process.stdout,\n  //       isDir: () => false\n  //     }\n  //     debug('writing to stdout');\n  //   } else {\n\n  //     debug('argv._[1]=', argv._[1])\n  //     const dest = path.resolve(argv._[1]);\n  //     debug('dest=', dest)\n\n  //     if (argv._[1].endsWith(path.sep)) {\n  //       // handle out as directory\n\n  //       // check if the directory exists\n  //       if (!directoryExists(dest)) {\n  //         createDirectory(dest)\n  //       }\n  //       ret.out = {\n  //         name: dest,\n  //         createStream: () => fs.createWriteStream(dest, { flags: 'w' }),\n  //         isDir: () => true\n  //       }\n  //     }\n  //     else {\n  //       // handleOutAsFile\n\n  //       const destDir = path.dirname(argv._[1]);\n\n  //       // check if the directory exists\n  //       if (!directoryExists(destDir)) {\n  //         createDirectory(destDir)\n  //       }\n  //       ret.out = {\n  //         name: argv._[1],\n  //         createStream: () => {\n  //           return fs.createWriteStream(dest, { flags: 'w' })\n  //         },\n  //         isDir: () => false\n  //       }\n\n  //     }\n  //   }\n  // }\n\n  // if (argv.hasOwnProperty('f')) {\n  //   ret.override = argv.f\n  // }\n  // if (argv.hasOwnProperty('allow-digits-to-start-css-classes')) {\n  //   ret.allowDigitToStartClassName = !!argv['allow-digits-to-start-css-classes']\n  //   debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n  // } else if (argv.hasOwnProperty('allowDigitToStartClassName')) {\n  //   ret.allowDigitToStartClassName = new Boolean(argv['allowDigitToStartClassName'])\n  //   debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n  // }\n\n  // return ret\n}\n\nexport default parseArguments;\n"],"names":["$4226c92db7aa915b$var$debug","$bJOKe$debug","$4226c92db7aa915b$export$777d1004acb65c30","fileExtWithDot","toLowerCase","$4226c92db7aa915b$export$f7e9f41ea797a17","filename","$bJOKe$fs","accessSync","e","$4226c92db7aa915b$export$48c572a28526d6a4","dir","constants","R_OK","$4226c92db7aa915b$export$ec6cea1e356a6713","mkdirSync","recursive","$4226c92db7aa915b$export$af6bad00634a71e4","originalDir","process","cwd","notFound","F_OK","chdir","pkgDir","Array","prototype","peek","this","length","String","removeFromEnd","str","endsWith","substring","lastIndexOf","toString","$b1ddc3f21e90a87c$var$debug","$b1ddc3f21e90a87c$var$isInTest","$b1ddc3f21e90a87c$export$2e2bcd8739ae039","processOrArgv1","printUsage","options","undefined","optional","requiredParams1","required","ret","args","processOrArgv","hasOwnProperty","argv","startsWith","title","nodePath","program","slice","includes","exit","internalOptions","internalArgs","i","element","push","key","val","split","skipCreateStreamFunctions","inFilename","outFilename","in","inObj","name","createStream","stdin","isDir","resolvedIn","$bJOKe$nodepath","resolve","$bJOKe$nodefs","console","error","Error","syscall","path","createReadStream","lstatSync","isDirectory","files","readdirSync","withFileTypes","filter","dirent","isFile","isSupportedFileExtension","extname","map","dirrent","createInObject","out","outObj","stdout","dest","sep","createWriteStream","flags","destDir","dirname","createOutObject","argumentsAndOptions","checkCollectionForNameOrAlias","nameAndAliases","parameterCollection","argumentsHaveNameOrAlias","isArray","some","Object","keys","forEach","requiredParameter","aliases","concat","doArgumentsOrOptionsHaveNameOrAlias","checkForRequiredParam"],"version":3,"file":"index.js.map","sourceRoot":"../../../"}