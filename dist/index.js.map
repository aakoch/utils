{"mappings":"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","sources":["src/utils.js","src/parse_arguments.js","src/decorate_args.js","src/index.js"],"sourcesContent":["import debugFunc from 'debug'\nimport fs from 'fs'\n\nconst debug = debugFunc('@foo-dog/utils')\n\nfunction isSupportedFileExtension(fileExtWithDot) {\n  return fileExtWithDot.toLowerCase() == '.pug' || fileExtWithDot.toLowerCase() == '.foo-dog' || fileExtWithDot.toLowerCase() == '.fd'\n}\n\nArray.prototype.peek = function () {\n  return this[this.length - 1]\n}\n\nString.prototype.removeFromEnd = function (str) {\n  return this.endsWith(str) ? this.substring(0, this.lastIndexOf(str)) : this.toString()\n}\n\nfunction exists(filename) {\n  try {\n    return (fs.accessSync(filename), true)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction directoryExists(dir) {\n  try {\n    // fs.lstatSync(destFileToWriteTo)\n    fs.accessSync(dir, fs.constants.R_OK)\n    return true\n  } catch (e) { }\n  return false\n}\n\nfunction createDirectory(dir) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\nfunction simpleProjectRootDir() {\n  const originalDir = process.cwd()\n  let notFound = true\n  while (notFound) {\n    try {\n      fs.accessSync('package.json', fs.constants.F_OK)\n      notFound = false\n    } catch (e) {\n      process.chdir('..')\n    }\n  }\n  const pkgDir = process.cwd()\n  process.chdir(originalDir)\n  return pkgDir\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  directoryExists,\n  createDirectory,\n  simpleProjectRootDir\n}","import debugFunc from 'debug'\nconst debug = debugFunc('@foo-dog/utils:parse_arguments')\n\nfunction isNodeProcess(processOrArgv) {\n  debug('processOrArgv=', processOrArgv)\n\n  return (\n    typeof processOrArgv === 'object' &&\n    processOrArgv.hasOwnProperty('argv') &&\n    processOrArgv.argv[0].startsWith('/') &&\n    processOrArgv.title.endsWith('node')\n  )\n}\n\nfunction checkForRequiredParameters(requiredParams, argumentsAndOptions) {\n  requiredParams.forEach(requiredParameter => {\n    checkForRequiredParam(requiredParameter, argumentsAndOptions)\n  })\n}\n\nfunction checkForRequiredParam(requiredParameter, argumentsAndOptions) {\n  const nameAndAliases = createNameAndAliasesArray(requiredParameter)\n\n  const argumentsHasNameOrAlias = doArgumentsOrOptionsHaveNameOrAlias(nameAndAliases, argumentsAndOptions)\n\n  if (!argumentsHasNameOrAlias) {\n    throw new Error('Required field \"' + requiredParameter.name + '\" was not found')\n  }\n}\n\nfunction createNameAndAliasesArray(requiredParameter) {\n  let nameAndAliases = [requiredParameter.name]\n  if (requiredParameter.aliases) {\n    nameAndAliases = nameAndAliases.concat(requiredParameter.aliases)\n  }\n  return nameAndAliases\n}\n\n/**\n * @returns boolean\n */\nfunction doArgumentsOrOptionsHaveNameOrAlias(nameAndAliases, argumentsAndOptions) {\n  return (\n    checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.args) ||\n    checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.options)\n  )\n}\n\nfunction checkCollectionForNameOrAlias(nameAndAliases, parameterCollection) {\n  let argumentsHaveNameOrAlias = false\n\n  debug('nameAndAliases=', nameAndAliases)\n  debug('parameterCollection=', parameterCollection)\n\n  if (parameterCollection != undefined) {\n    if (Array.isArray(parameterCollection) && parameterCollection.length) {\n      argumentsHaveNameOrAlias = nameAndAliases.some(name => parameterCollection.includes(name))\n    } else if (typeof parameterCollection === 'object') {\n      argumentsHaveNameOrAlias = nameAndAliases.some(name => parameterCollection.hasOwnProperty(name))\n    } else {\n      console.error(\n        'Unexpected error in checkCollectionForNameOrAlias(). nameAndAliases=',\n        nameAndAliases,\n        ', parameterCollection=',\n        parameterCollection\n      )\n      throw new Error('Unexpected error (and nothing coded to handle it)')\n    }\n  }\n  return argumentsHaveNameOrAlias\n}\n\n/**\n * @param processOrArgv A Node process or an array of command line parameters\n * @param printUsage The function to print when \"-h\" or \"--help\" is a parameter\n * @param options optional and required parameters:\n *        {\n *          optional: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ],\n *          required: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ]\n *        }\n */\n// This isn't fully flushed out yet\nasync function parseArguments(processOrArgv, printUsage, options) {\n  if (options == undefined) {\n    options = typeof printUsage === 'object' ? printUsage : {}\n  }\n\n  const optionalParams = options.optional ?? []\n  const requiredParams = options.required ?? []\n\n  debug('optional parameters=', optionalParams)\n  debug('required parameters=', requiredParams)\n\n  const ret = {}\n  let args\n  if (isNodeProcess(processOrArgv)) {\n    ret.nodePath = processOrArgv.argv[0]\n    ret.program = processOrArgv.argv[1]\n    args = processOrArgv.argv.slice(2)\n  } else {\n    args = processOrArgv?.argv || processOrArgv\n  }\n\n  if (args.includes('-h') || args.includes('--help')) {\n    if (printUsage != undefined && typeof printUsage === 'function') {\n      printUsage()\n    } else {\n      debug('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n    }\n  } else {\n    const internalOptions = {},\n      internalArgs = []\n\n    args.forEach(element => {\n      if (element === '-') {\n        internalArgs.push(element)\n      } else if (element.startsWith('--')) {\n        const [key, val] = element.split('=')\n        internalOptions[key.slice(2)] = val || true\n      } else if (element.startsWith('-')) {\n        const [key, val] = element.split('=')\n        internalOptions[key.slice(1)] = val || true\n      } else {\n        internalArgs.push(element)\n      }\n    })\n\n    if (internalArgs.length > 0) {\n      ret.args = internalArgs\n    }\n\n    if (Object.keys(internalOptions).length > 0) {\n      ret.options = internalOptions\n    }\n\n    checkForRequiredParameters(requiredParams, ret)\n\n    return ret\n  }\n\n}\n\nexport default parseArguments\n","import path from 'node:path'\nimport fs from 'fs'\nimport { readdirSync } from 'node:fs'\nimport { exists } from '../src/utils.js'\nimport debugFunc from 'debug'\nconst debug = debugFunc('@foo-dog/utils:decorate_args')\n\nfunction createCreateReadStreamFunc(filename) {\n  try {\n    debug('createCreateReadStreamFunc(): looking for', filename)\n    const stat = fs.statSync(filename)\n    debug('createCreateReadStreamFunc(): found', filename)\n    debug('createCreateReadStreamFunc(): stat.isDirectory()=', stat.isDirectory())\n    return () => fs.createReadStream(filename)\n  }\n  catch (e) {\n    debug('createCreateReadStreamFunc(): didn\\'t find', filename)\n    if (e.message == \"ENOENT: no such file or directory, stat '\" + filename + \"'\")\n      return () => { throw new Error('file not found') }\n    else\n      throw e\n  }\n}\n\nfunction isWritableDirectory(dir) {\n  try {\n\n    debug('isWritableDirectory(): dir=', dir)\n    if (fs.statSync(dir).isDirectory()) {\n      fs.accessSync(dir, fs.constants.R_OK | fs.constants.W_OK)\n      return true\n    }\n    return false\n  }\n  catch (e) {\n    if (e.code === 'ENOTDIR' || e.code === 'ENOENT')\n      return false\n\n    console.error(\"Error testing if \" + dir + \" is a directory. Error: \" + e.message)\n    throw e\n  }\n}\n\nfunction createObject(inOrOutput, processStreamFunc, fileFunc, dirFunc) {\n  \n  if (inOrOutput === 'stdin' || inOrOutput === 'stdout') {\n    return processStreamFunc()\n  }\n  else {\n    const resolvedName = path.resolve(inOrOutput)\n    if (isWritableDirectory(resolvedName)) {\n      debug('createObject(): ' + resolvedName + ' is a writable directory')\n      return dirFunc(resolvedName)\n    }\n    else {\n      debug('createObject(): ' + resolvedName + ' is not a writable directory')\n      return fileFunc(resolvedName)\n    }\n  }\n\n  // options, direction, directoryFunction) {\n\n  // if (options[direction]?.name) {\n  //   const resolvedName = path.resolve(options[direction].name)\n  //   if (isWritableDirectory(resolvedName)) {\n  //     options[direction].isDir = () => true\n  //     directoryFunction(options)\n  //   }\n  //   else {\n  //     options[direction].isDir = () => false\n  //     if (direction === 'in') {\n  //       options[direction].createStream = createReadCreateStreamFunc(resolvedName)\n  //     }\n  //   }\n  //   options[direction].name = options[direction]?.name === 'stdin' || options[direction]?.name === 'stdout' ? options[direction]?.name : resolvedName\n  // }\n}\n\nfunction defaultInName(obj) {\n  return obj?.in?.name ?? 'stdin'\n}\n\nfunction defaultOutName(obj) {\n  return obj?.out?.name ?? 'stdout'\n}\n\nexport default {\n  withCreateStreams(options = {}) {\n\n    debug('withCreateStreams(): options=', options)\n\n    const decoratedOptions = {...options}\n\n    if (options?.in?.name) {\n      decoratedOptions.in = createObject(\n        defaultInName(options),\n        () => ({ \n          name: 'stdin',\n          createStream: () => process.stdin,\n          isDir: () => false\n        }),\n        (filename) => ({ \n          name: path.resolve(filename),\n          createStream: createCreateReadStreamFunc(path.resolve(filename)),\n          isDir: () => false\n        }),\n        (directory) => ({\n          name: directory,\n          files: readdirSync(directory),\n          isDir: () => true\n        })\n      )\n    }\n\n    if (options?.out?.name) {\n      decoratedOptions.out = createObject(\n        defaultOutName(options),\n        () => ({ \n          name: 'stdout',\n          createStream: () => process.stdout,\n          isDir: () => false\n        }),\n        (filename) => ({ \n          name: filename,\n          createStream: () => fs.createWriteStream(filename),\n          isDir: () => false\n        }),\n        (directory) => {\n          debug('withCreateStreams(): directory=', directory)\n\n          const outObj = {name: directory, isDir: () => true}\n          // If we are in here, out.name ends with a path separator\n          const dirName = path.resolve(directory)\n          outObj.name = path.resolve(dirName, path.parse(decoratedOptions.in.name).name)\n          try {\n            outObj.createStream = () => fs.createWriteStream(outObj.name)\n          }\n          catch (e) {\n            console.error('Could not find directory: ' + dirName + ' or write ' + outObj.name + ': ' + e.message)\n            if (e.message == \"ENOENT: no such file or directory, stat '\" + dirName + \"'\")\n              return () => { throw new Error('file not found') }\n            else\n              throw e\n          }\n          return outObj\n        }\n      )\n    }\n\n    debug('withCreateStreams(): decoratedOptions=', decoratedOptions)\n\n    return decoratedOptions\n  }\n}\n","import {\n  isSupportedFileExtension,\n  simpleProjectRootDir,\n  exists\n} from '../src/utils.js'\nimport originalParseArguments from '../src/parse_arguments.js'\nimport decorateArgs from '../src/decorate_args.js'\n\nfunction defined(obj) {\n  return obj != null && obj != undefined\n}\n\nfunction existsLength(obj, keyForArray) {\n  return defined(obj) && defined(obj[keyForArray]) && Array.isArray(obj[keyForArray]) ? obj[keyForArray].length : -1\n}\n\nfunction defaultInName(obj) {\n  return existsLength(obj, 'args') > 0 ? obj.args[0] : 'stdin'\n}\n\nfunction defaultOutName(obj) {\n  return existsLength(obj, 'args') > 1 ? obj.args[1] : 'stdout'\n}\n\nconst parseArguments = async (...arr) => {\n  const parsedArgs = await originalParseArguments(...arr)\n  const newArgs = {...parsedArgs}\n  newArgs.in = { name: defaultInName(parsedArgs) }\n  newArgs.out = { name: defaultOutName(parsedArgs) }\n  return decorateArgs.withCreateStreams(newArgs)\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  parseArguments,\n  simpleProjectRootDir\n}"],"names":["$249sc$debug","$32b18f4c344ee415$export$777d1004acb65c30","fileExtWithDot","toLowerCase","$32b18f4c344ee415$export$f7e9f41ea797a17","filename","$249sc$fs","accessSync","e","$32b18f4c344ee415$export$af6bad00634a71e4","originalDir","process","cwd","notFound","constants","F_OK","chdir","pkgDir","Array","prototype","peek","this","length","String","removeFromEnd","str","endsWith","substring","lastIndexOf","toString","$dae08edc6d7e5182$var$debug","$dae08edc6d7e5182$var$checkForRequiredParameters","requiredParams","argumentsAndOptions","forEach","requiredParameter","nameAndAliases","name","aliases","concat","$dae08edc6d7e5182$var$createNameAndAliasesArray","$dae08edc6d7e5182$var$checkCollectionForNameOrAlias","args","options","$dae08edc6d7e5182$var$doArgumentsOrOptionsHaveNameOrAlias","Error","$dae08edc6d7e5182$var$checkForRequiredParam","parameterCollection","argumentsHaveNameOrAlias","undefined","isArray","some","includes","console","error","hasOwnProperty","$dae08edc6d7e5182$export$2e2bcd8739ae039","async","processOrArgv","printUsage","optionalParams","optional","required","ret","argv","startsWith","title","$dae08edc6d7e5182$var$isNodeProcess","nodePath","program","slice","internalOptions","internalArgs","element","push","key","val","split","Object","keys","$f0ceba822c4d0747$var$debug","$f0ceba822c4d0747$var$createCreateReadStreamFunc","stat","statSync","isDirectory","createReadStream","message","$f0ceba822c4d0747$var$createObject","inOrOutput","processStreamFunc","fileFunc","dirFunc","resolvedName","$249sc$nodepath","resolve","dir","R_OK","W_OK","code","$f0ceba822c4d0747$var$isWritableDirectory","$f0ceba822c4d0747$export$2e2bcd8739ae039","withCreateStreams","decoratedOptions","in","createStream","stdin","isDir","directory","files","$249sc$readdirSync","out","obj","$f0ceba822c4d0747$var$defaultOutName","stdout","createWriteStream","outObj","dirName","parse","$ed15f9a4a5c4e622$var$defined","$ed15f9a4a5c4e622$var$existsLength","keyForArray","$ed15f9a4a5c4e622$var$defaultOutName","$ed15f9a4a5c4e622$export$63c5b6d6ff5b7ee1","arr","parsedArgs","newArgs"],"version":3,"file":"index.js.map","sourceRoot":"../"}