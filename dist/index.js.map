{"mappings":"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","sources":["workspaces/utils/src/utils.js","workspaces/utils/src/parse_arguments.js","workspaces/utils/src/decorate_args.js","workspaces/utils/src/index.js"],"sourcesContent":["import debugFunc from 'debug'\nimport fs from 'fs'\n\nconst debug = debugFunc('@foo-dog/utils')\n\nfunction isSupportedFileExtension(fileExtWithDot) {\n  return fileExtWithDot.toLowerCase() == '.pug' || fileExtWithDot.toLowerCase() == '.foo-dog' || fileExtWithDot.toLowerCase() == '.fd'\n}\n\nArray.prototype.peek = function () {\n  return this[this.length - 1]\n}\n\nString.prototype.removeFromEnd = function (str) {\n  return this.endsWith(str) ? this.substring(0, this.lastIndexOf(str)) : this.toString()\n}\n\nfunction exists(filename) {\n  try {\n    return (fs.accessSync(filename), true)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction directoryExists(dir) {\n  try {\n    // fs.lstatSync(destFileToWriteTo)\n    fs.accessSync(dir, fs.constants.R_OK)\n    return true\n  } catch (e) { }\n  return false\n}\n\nfunction createDirectory(dir) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\nfunction simpleProjectRootDir() {\n  const originalDir = process.cwd()\n  let notFound = true\n  while (notFound) {\n    try {\n      fs.accessSync('package.json', fs.constants.F_OK)\n      notFound = false\n    } catch (e) {\n      process.chdir('..')\n    }\n  }\n  const pkgDir = process.cwd()\n  process.chdir(originalDir)\n  return pkgDir\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  directoryExists,\n  createDirectory,\n  simpleProjectRootDir\n}","import debugFunc from 'debug'\nconst debug = debugFunc('@foo-dog/utils:parse_arguments')\n\nfunction isNodeProcess(processOrArgv) {\n  debug('processOrArgv=', processOrArgv)\n\n  return (\n    typeof processOrArgv === 'object' &&\n    processOrArgv.hasOwnProperty('argv') &&\n    processOrArgv.argv[0].startsWith('/') &&\n    processOrArgv.title.endsWith('node')\n  )\n}\n\nfunction checkForRequiredParameters(requiredParams, argumentsAndOptions) {\n  requiredParams.forEach(requiredParameter => {\n    checkForRequiredParam(requiredParameter, argumentsAndOptions)\n  })\n}\n\nfunction checkForRequiredParam(requiredParameter, argumentsAndOptions) {\n  const nameAndAliases = createNameAndAliasesArray(requiredParameter)\n\n  const argumentsHasNameOrAlias = doArgumentsOrOptionsHaveNameOrAlias(nameAndAliases, argumentsAndOptions)\n\n  if (!argumentsHasNameOrAlias) {\n    throw new Error('Required field \"' + requiredParameter.name + '\" was not found')\n  }\n}\n\nfunction createNameAndAliasesArray(requiredParameter) {\n  let nameAndAliases = [requiredParameter.name]\n  if (requiredParameter.aliases) {\n    nameAndAliases = nameAndAliases.concat(requiredParameter.aliases)\n  }\n  return nameAndAliases\n}\n\n/**\n * @returns boolean\n */\nfunction doArgumentsOrOptionsHaveNameOrAlias(nameAndAliases, argumentsAndOptions) {\n  return (\n    checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.args) ||\n    checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.options)\n  )\n}\n\nfunction checkCollectionForNameOrAlias(nameAndAliases, parameterCollection) {\n  let argumentsHaveNameOrAlias = false\n\n  debug('nameAndAliases=', nameAndAliases)\n  debug('parameterCollection=', parameterCollection)\n\n  if (parameterCollection != undefined) {\n    if (Array.isArray(parameterCollection) && parameterCollection.length) {\n      argumentsHaveNameOrAlias = nameAndAliases.some(name => parameterCollection.includes(name))\n    } else if (typeof parameterCollection === 'object') {\n      argumentsHaveNameOrAlias = nameAndAliases.some(name => parameterCollection.hasOwnProperty(name))\n    } else {\n      console.error(\n        'Unexpected error in checkCollectionForNameOrAlias(). nameAndAliases=',\n        nameAndAliases,\n        ', parameterCollection=',\n        parameterCollection\n      )\n      throw new Error('Unexpected error (and nothing coded to handle it)')\n    }\n  }\n  return argumentsHaveNameOrAlias\n}\n\n/**\n * @param processOrArgv A Node process or an array of command line parameters\n * @param printUsage The function to print when \"-h\" or \"--help\" is a parameter\n * @param options optional and required parameters:\n *        {\n *          optional: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ],\n *          required: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ]\n *        }\n */\n// This isn't fully flushed out yet\nasync function parseArguments(processOrArgv, printUsage, options) {\n  if (options == undefined) {\n    options = typeof printUsage === 'object' ? printUsage : {}\n  }\n\n  const optionalParams = options.optional ?? []\n  const requiredParams = options.required ?? []\n\n  debug('optional parameters=', optionalParams)\n  debug('required parameters=', requiredParams)\n\n  const ret = {}\n  let args\n  if (isNodeProcess(processOrArgv)) {\n    ret.nodePath = processOrArgv.argv[0]\n    ret.program = processOrArgv.argv[1]\n    args = processOrArgv.argv.slice(2)\n  } else {\n    args = processOrArgv?.argv || processOrArgv\n  }\n\n  if (args.includes('-h') || args.includes('--help')) {\n    if (printUsage != undefined && typeof printUsage === 'function') {\n      printUsage()\n    } else {\n      debug('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n    }\n  } else {\n    const internalOptions = {},\n      internalArgs = []\n\n    args.forEach(element => {\n      if (element === '-') {\n        internalArgs.push(element)\n      } else if (element.startsWith('--')) {\n        const [key, val] = element.split('=')\n        internalOptions[key.slice(2)] = val || true\n      } else if (element.startsWith('-')) {\n        const [key, val] = element.split('=')\n        internalOptions[key.slice(1)] = val || true\n      } else {\n        internalArgs.push(element)\n      }\n    })\n\n    if (internalArgs.length > 0) {\n      ret.args = internalArgs\n    }\n\n    if (Object.keys(internalOptions).length > 0) {\n      ret.options = internalOptions\n    }\n\n    checkForRequiredParameters(requiredParams, ret)\n\n    return ret\n  }\n\n}\n\nexport default parseArguments\n","import path from 'node:path'\nimport fs from 'fs'\nimport { readdirSync } from 'node:fs'\nimport { exists } from '../src/utils.js'\nimport debugFunc from 'debug'\nconst debug = debugFunc('@foo-dog/utils:decorate_args')\n\nfunction createCreateReadStreamFunc(filename) {\n  try {\n    debug('createCreateReadStreamFunc(): looking for', filename)\n    const stat = fs.statSync(filename)\n    debug('createCreateReadStreamFunc(): found', filename)\n    debug('createCreateReadStreamFunc(): stat.isDirectory()=', stat.isDirectory())\n    return () => fs.createReadStream(filename)\n  }\n  catch (e) {\n    debug('createCreateReadStreamFunc(): didn\\'t find', filename)\n    if (e.message == \"ENOENT: no such file or directory, stat '\" + filename + \"'\")\n      return () => { throw new Error('file not found') }\n    else\n      throw e\n  }\n}\n\nfunction isWritableDirectory(dir) {\n  try {\n\n    debug('isWritableDirectory(): dir=', dir)\n    if (fs.statSync(dir).isDirectory()) {\n      fs.accessSync(dir, fs.constants.R_OK | fs.constants.W_OK)\n      return true\n    }\n    return false\n  }\n  catch (e) {\n    if (e.code === 'ENOTDIR' || e.code === 'ENOENT')\n      return false\n\n    console.error(\"Error testing if \" + dir + \" is a directory. Error: \" + e.message)\n    throw e\n  }\n}\n\nfunction createObject(inOrOutput, processStreamFunc, fileFunc, dirFunc) {\n  \n  if (inOrOutput === 'stdin' || inOrOutput === 'stdout') {\n    return processStreamFunc()\n  }\n  else {\n    const resolvedName = path.resolve(inOrOutput)\n    if (isWritableDirectory(resolvedName)) {\n      debug('createObject(): ' + resolvedName + ' is a writable directory')\n      return dirFunc(resolvedName)\n    }\n    else {\n      debug('createObject(): ' + resolvedName + ' is not a writable directory')\n      return fileFunc(resolvedName)\n    }\n  }\n\n  // options, direction, directoryFunction) {\n\n  // if (options[direction]?.name) {\n  //   const resolvedName = path.resolve(options[direction].name)\n  //   if (isWritableDirectory(resolvedName)) {\n  //     options[direction].isDir = () => true\n  //     directoryFunction(options)\n  //   }\n  //   else {\n  //     options[direction].isDir = () => false\n  //     if (direction === 'in') {\n  //       options[direction].createStream = createReadCreateStreamFunc(resolvedName)\n  //     }\n  //   }\n  //   options[direction].name = options[direction]?.name === 'stdin' || options[direction]?.name === 'stdout' ? options[direction]?.name : resolvedName\n  // }\n}\n\nfunction defaultInName(obj) {\n  const inName = obj?.in?.name ?? 'stdin'\n  return inName === '-' ? 'stdin' : inName\n}\n\nfunction defaultOutName(obj) {\n  const outName = obj?.out?.name ?? 'stdout'\n  return outName === '-' ? 'stdout' : outName\n}\n\nexport default {\n  withCreateStreams(options = {}) {\n\n    debug('withCreateStreams(): options=', options)\n\n    const decoratedOptions = {...options}\n\n    if (options?.in?.name) {\n      decoratedOptions.in = createObject(\n        defaultInName(options),\n        () => ({ \n          name: 'stdin',\n          createStream: () => process.stdin,\n          isDir: () => false\n        }),\n        (filename) => ({ \n          name: path.resolve(filename),\n          createStream: createCreateReadStreamFunc(path.resolve(filename)),\n          isDir: () => false\n        }),\n        (directory) => ({\n          name: directory,\n          files: readdirSync(directory),\n          isDir: () => true\n        })\n      )\n    }\n\n    if (options?.out?.name) {\n      decoratedOptions.out = createObject(\n        defaultOutName(options),\n        () => ({ \n          name: 'stdout',\n          createStream: () => process.stdout,\n          isDir: () => false\n        }),\n        (filename) => ({ \n          name: filename,\n          createStream: () => fs.createWriteStream(filename),\n          isDir: () => false\n        }),\n        (directory) => {\n          debug('withCreateStreams(): directory=', directory)\n\n          const outObj = {name: directory, isDir: () => true}\n          // If we are in here, out.name ends with a path separator\n          const dirName = path.resolve(directory)\n          if (decoratedOptions.in.isDir()) {\n            outObj.name = path.resolve(dirName)\n          }\n          else {\n            outObj.name = path.resolve(dirName, path.parse(decoratedOptions.in.name).name)\n          }\n          try {\n            outObj.createStream = () => fs.createWriteStream(outObj.name)\n          }\n          catch (e) {\n            console.error('Could not find directory: ' + dirName + ' or write ' + outObj.name + ': ' + e.message)\n            if (e.message == \"ENOENT: no such file or directory, stat '\" + dirName + \"'\")\n              return () => { throw new Error('file not found') }\n            else\n              throw e\n          }\n          return outObj\n        }\n      )\n    }\n\n    debug('withCreateStreams(): decoratedOptions=', decoratedOptions)\n\n    return decoratedOptions\n  }\n}\n","import {\n  isSupportedFileExtension,\n  simpleProjectRootDir,\n  exists\n} from '../src/utils.js'\nimport originalParseArguments from '../src/parse_arguments.js'\nimport decorateArgs from '../src/decorate_args.js'\n\nfunction defined(obj) {\n  return obj != null && obj != undefined\n}\n\nfunction existsLength(obj, keyForArray) {\n  return defined(obj) && defined(obj[keyForArray]) && Array.isArray(obj[keyForArray]) ? obj[keyForArray].length : -1\n}\n\nfunction defaultInName(obj) {\n  return existsLength(obj, 'args') > 0 ? obj.args[0] : 'stdin'\n}\n\nfunction defaultOutName(obj) {\n  return existsLength(obj, 'args') > 1 ? obj.args[1] : 'stdout'\n}\n\nconst parseArguments = async (...arr) => {\n  const parsedArgs = await originalParseArguments(...arr)\n  const newArgs = {...parsedArgs}\n  newArgs.in = { name: defaultInName(parsedArgs) }\n  newArgs.out = { name: defaultOutName(parsedArgs) }\n  return decorateArgs.withCreateStreams(newArgs)\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  parseArguments,\n  simpleProjectRootDir\n}"],"names":["$bJOKe$debug","$4226c92db7aa915b$export$777d1004acb65c30","fileExtWithDot","toLowerCase","$4226c92db7aa915b$export$f7e9f41ea797a17","filename","$bJOKe$fs","accessSync","e","$4226c92db7aa915b$export$af6bad00634a71e4","originalDir","process","cwd","notFound","constants","F_OK","chdir","pkgDir","Array","prototype","peek","this","length","String","removeFromEnd","str","endsWith","substring","lastIndexOf","toString","$b1ddc3f21e90a87c$var$debug","$b1ddc3f21e90a87c$var$checkForRequiredParameters","requiredParams","argumentsAndOptions","forEach","requiredParameter","nameAndAliases","name","aliases","concat","$b1ddc3f21e90a87c$var$createNameAndAliasesArray","$b1ddc3f21e90a87c$var$checkCollectionForNameOrAlias","args","options","$b1ddc3f21e90a87c$var$doArgumentsOrOptionsHaveNameOrAlias","Error","$b1ddc3f21e90a87c$var$checkForRequiredParam","parameterCollection","argumentsHaveNameOrAlias","undefined","isArray","some","includes","console","error","hasOwnProperty","$b1ddc3f21e90a87c$export$2e2bcd8739ae039","processOrArgv","printUsage","optionalParams","optional","required","ret","argv","startsWith","title","$b1ddc3f21e90a87c$var$isNodeProcess","nodePath","program","slice","internalOptions","internalArgs","element","push","key","val","split","Object","keys","$6e43e11cccfc60f7$var$debug","$6e43e11cccfc60f7$var$createCreateReadStreamFunc","stat","statSync","isDirectory","createReadStream","message","$6e43e11cccfc60f7$var$createObject","inOrOutput","processStreamFunc","fileFunc","dirFunc","resolvedName","$bJOKe$nodepath","resolve","dir","R_OK","W_OK","code","$6e43e11cccfc60f7$var$isWritableDirectory","$6e43e11cccfc60f7$export$2e2bcd8739ae039","withCreateStreams","ref","ref1","decoratedOptions","in","obj","inName","$6e43e11cccfc60f7$var$defaultInName","createStream","stdin","isDir","directory","files","$bJOKe$readdirSync","out","outName","$6e43e11cccfc60f7$var$defaultOutName","stdout","createWriteStream","outObj","dirName","parse","$fdeccbe171b4469a$var$defined","$fdeccbe171b4469a$var$existsLength","keyForArray","$fdeccbe171b4469a$var$defaultOutName","$fdeccbe171b4469a$export$63c5b6d6ff5b7ee1","async","arr","parsedArgs","newArgs"],"version":3,"file":"index.js.map","sourceRoot":"../../../"}