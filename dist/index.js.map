{"mappings":"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","sources":["workspaces/utils/src/utils.js","workspaces/utils/src/parse_arguments.js"],"sourcesContent":["import minimist from 'minimist';\nimport debugFunc from 'debug'\nimport path from 'path'\nimport fs from 'fs'\nimport { randomInt } from 'crypto';\n\nconst debug = debugFunc('@foo-dog:utils')\n\nfunction isSupportedFileExtension(fileExtWithDot) {\n  debug('isSupportedFileExtension(): fileExtWithDot=' + fileExtWithDot)\n  return fileExtWithDot.toLowerCase() == '.pug' || fileExtWithDot.toLowerCase() == '.foo-dog'\n}\n\nArray.prototype.peek = function () {\n  return this[this.length - 1]\n}\n\nString.prototype.removeFromEnd = function (str) {\n  return this.endsWith(str) ? this.substring(0, this.lastIndexOf(str)) : this.toString()\n}\n\nfunction exists(filename) {\n  try {\n    return (fs.accessSync(filename), true)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction directoryExists(dir) {\n  try {\n    // fs.lstatSync(destFileToWriteTo)\n    fs.accessSync(dir, fs.constants.R_OK)\n    return true\n  } catch (e) { }\n  return false\n}\n\nfunction createDirectory(dir) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\n/**\n * @param process Node process (TODO: pass in arguments only)\n * @param printUsage function\n */\n// This isn't fully flushed out yet\nasync function parseArguments(process, printUsage) {\n  const argv = minimist(process.argv.slice(2))\n  // debug('argv=', argv)\n\n\n  \n  let ret = { in: {}, out: {} }\n\n  if (argv.help || argv.h) {\n    debug('help option detected')\n    if (printUsage != undefined && typeof printUsage === 'function') {\n      printUsage()\n    }\n    else {\n      console.log('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n    }\n    process.exit()\n  } else if (argv._.length == 0) {\n    debug('no arguments - using stdin and stdout')\n    ret = { \n      in: { \n        name: 'stdin', \n        createStream: () => process.stdin, \n        isDir: () => false \n      }, \n      out: { \n        name: 'stdout', \n        createStream: () => process.stdout, \n        isDir: () => false\n      }\n    }\n  } else if (argv._.length == 1) {\n    debug('one argument - reading file and piping to stdout')\n    try {\n      fs.accessSync(argv._[0], fs.constants.R_OK)\n    } catch (e) {\n      throw new Error(`Could not ${e.syscall} \"${e.path}\"`)\n    }\n\n    // debug('creating read stream for ' + argv?._[0])\n    const resolvedIn = path.resolve(argv._[0])\n\n    ret = {\n      in: {\n        name: argv._[0],\n        createStream: () => fs.createReadStream(resolvedIn),\n        isDir: () => fs.lstatSync(argv._[0]).isDirectory(),\n        files: () => fs.lstatSync(resolvedIn).isDirectory() ? fs.readdirSync(resolvedIn, { withFileTypes: true }).filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1)))).map(dirrent => dirrent.name) : resolvedIn\n      },\n      out: { name: 'stdout', createStream: () => process.stdout, isDir: () => false },\n      override: argv.f\n    }\n  } else {\n    debug('two or more arguments')\n\n    if (argv._[0] == '-') {\n      debug('first argument was - - using stdin')\n      ret.in = {\n        name: 'stdin',\n        createStream: () => process.stdin,\n        isDir: () => false\n      }\n      debug('Reading from stdin');\n    } else {\n      const resolvedIn = path.resolve(argv._[0])\n      debug(`first argument was ${argv._[0]}. Resolved is ${resolvedIn}`)\n      try {\n        fs.accessSync(resolvedIn, fs.constants.R_OK)\n\n        debug('fs.readdirSync(resolvedIn)=', fs.readdirSync(resolvedIn))\n\n        ret.in = {\n          name: resolvedIn,\n          createStream: () => fs.createReadStream(resolvedIn),\n          isDir: () => fs.lstatSync(resolvedIn).isDirectory(),\n          files: () => {\n            if (fs.lstatSync(resolvedIn).isDirectory()) {\n              return fs\n                .readdirSync(resolvedIn, { withFileTypes: true })\n                .filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1))))\n                .map(dirrent => {\n                  debug('dirrent.name=' + dirrent.name)\n                  debug('path.resolve(resolvedIn, dirrent.name)=' + path.resolve(resolvedIn, dirrent.name))\n                  return path.resolve(resolvedIn, dirrent.name)\n                }) \n             }\n             else {\n              return resolvedIn\n             }\n          }\n        }\n      } catch (e) {\n        if (e.hasOwnProperty('syscall'))\n          throw new Error(`Could not ${e.syscall} \"${e.path}\"`, { cause: e })\n        else\n          throw e;\n      }\n    }\n\n    if (argv._[1] == '-') {\n      debug('second argument was - - using stdout')\n      ret.out = {\n        name: 'stdout',\n        createStream: () => process.stdout,\n        isDir: () => false\n      }\n      debug('writing to stdout');\n    } else {\n\n      debug('argv._[1]=', argv._[1])\n      const dest = path.resolve(argv._[1]);\n      debug('dest=', dest)\n\n      if (argv._[1].endsWith(path.sep)) {\n        // handle out as directory\n        \n        // check if the directory exists\n        if (!directoryExists(dest)) {\n          createDirectory(dest)\n        }\n        ret.out = {\n          name: dest,\n          createStream: () => fs.createWriteStream(dest, { flags: 'w' }),\n          isDir: () => true\n        }\n      }\n      else {\n        // handleOutAsFile\n\n        const destDir = path.dirname(argv._[1]);\n\n        // check if the directory exists\n        if (!directoryExists(destDir)) {\n          createDirectory(destDir)\n        }\n        ret.out = {\n          name: argv._[1],\n          createStream: () => {\n            return fs.createWriteStream(dest, { flags: 'w' })\n          },\n          isDir: () => false\n        }\n\n      }\n    }\n  }\n\n  if (argv.hasOwnProperty('f')) {\n    ret.override = argv.f\n  }\n  if (argv.hasOwnProperty('allow-digits-to-start-css-classes')) {\n    ret.allowDigitToStartClassName = !!argv['allow-digits-to-start-css-classes']\n    debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n  } else if (argv.hasOwnProperty('allowDigitToStartClassName')) {\n    ret.allowDigitToStartClassName = new Boolean(argv['allowDigitToStartClassName'])\n    debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n  }\n\n  return ret\n}\n\nfunction simpleProjectRootDir() {\n  const originalDir = process.cwd()\n  let notFound = true\n  while (notFound) {\n    try {\n      fs.accessSync('package.json', fs.constants.F_OK)\n      notFound = false\n    } catch (e) {\n      process.chdir('..')\n    }\n  }\n  const pkgDir = process.cwd()\n  process.chdir(originalDir)\n  return pkgDir\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  parseArguments,\n  simpleProjectRootDir\n}","import debugFunc from 'debug'\nconst debug = debugFunc('@foo-dog/utils:parse_arguments')\nconst shouldExit = !import.meta.url.endsWith('?test')\n\n/**\n * @param process Node process (TODO: pass in arguments only)\n * @param printUsage function to print when \"-h\" or \"--help\" is a parameter\n * @param options optional and required parameters:\n *        {\n *          optional: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ],\n *          required: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ]\n *        }\n */\n// This isn't fully flushed out yet\nasync function parseArguments(processOrArgv, printUsage, options) {\n\n  function looksLikeAProcess(processOrNot) {\n    debug('processOrNot=', processOrNot)\n    return processOrNot[0].startsWith('/') || processOrNot.hasOwnProperty('argv')\n  }\n\n  if (options == undefined) {\n    if (printUsage !== null && typeof printUsage === 'object') {\n      options = printUsage\n    }\n    else {\n      options = {}\n    }\n  }\n\n  const optionalParams = options.optional ?? []\n  const requiredParams = options.required ?? []\n\n  debug('options.required=', options.required)\n  debug('requiredParams=', requiredParams)\n\n  const ret = {}\n  let args\n  if (looksLikeAProcess(processOrArgv)) {\n    ret.nodePath = processOrArgv[0]\n    ret.program = processOrArgv[1]\n    args = processOrArgv.slice(2)\n  }\n  else {\n    args = processOrArgv?.argv || processOrArgv\n  }\n\n  if (args.includes('-h') || args.includes('--help')) {\n    printUsage()\n    if (shouldExit) {\n      process.exit(0)\n    }\n  }\n\n  const internalOptions = {}, internalArgs = []\n  for (let i = 0; i < args.length; i++) {\n    const element = args[i];\n    if (element.startsWith('-')) {\n      const [key, val] = element.split('=')\n      internalOptions[key] = val ?? true\n    }\n    else {\n      internalArgs.push(element)\n    }\n  }\n\n  if (internalArgs.length > 0) {\n    ret.args = internalArgs\n  }\n\n  if (Object.keys(internalOptions).length > 0) {\n    ret.options = internalOptions\n  }\n\n  debug('requiredParams.length=', requiredParams.length)\n  for (let reqIdx = 0; reqIdx < requiredParams.length; reqIdx++) {\n    const element = requiredParams[reqIdx];\n    debug('required=', element)\n    debug('ret?.args=', ret?.args)\n    debug('requiredParams[reqIdx].aliases=', requiredParams[reqIdx].aliases)\n\n    debug('(new Array()).concat(element.name).concat(requiredParams[reqIdx].aliases)=', (new Array()).concat(element.name).concat(requiredParams[reqIdx].aliases))\n    new Array(element.name).concat(requiredParams[reqIdx].aliases).forEach(requiredName => {\n      debug(requiredName)\n    })\n    if (!new Array(element.name).concat(requiredParams[reqIdx].aliases).some(requiredName => {\n      debug('!!ret?.args?.contains(requiredName)=', !!ret?.args?.contains(requiredName))\n      debug('ret?.options?.hasOwnProperty(requiredName)=', ret?.options?.hasOwnProperty(requiredName))\n      if (!!ret?.args?.contains(requiredName) || ret?.options?.hasOwnProperty(requiredName)) {\n        debug('don\\'t throw')\n        return true\n      }\n      else {\n        debug('throw')\n        return false\n      }\n    })) {\n      throw new Error('Required field \"' + element.name + '\" was not found')\n    }\n  }\n  \n  return ret\n\n\n  // // const argv = minimist(process.argv.slice(2))\n  // // debug('argv=', argv)\n  // let ret = { in: {}, out: {} }\n\n  // if (argv.help || argv.h) {\n  //   debug('help option detected')\n  //   if (printUsage != undefined && typeof printUsage === 'function') {\n  //     printUsage()\n  //   }\n  //   else {\n  //     debug('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n  //   }\n  //   process.exit()\n  // } else if (argv._.length == 0) {\n  //   debug('no arguments - using stdin and stdout')\n  //   ret = { \n  //     in: { \n  //       name: 'stdin', \n  //       createStream: () => process.stdin, \n  //       isDir: () => false \n  //     }, \n  //     out: { \n  //       name: 'stdout', \n  //       createStream: () => process.stdout, \n  //       isDir: () => false\n  //     }\n  //   }\n  // } else if (argv._.length == 1) {\n  //   debug('one argument - reading file and piping to stdout')\n  //   try {\n  //     fs.accessSync(argv._[0], fs.constants.R_OK)\n  //   } catch (e) {\n  //     throw new Error(`Could not ${e.syscall} \"${e.path}\"`)\n  //   }\n\n  //   // debug('creating read stream for ' + argv?._[0])\n  //   const resolvedIn = path.resolve(argv._[0])\n\n  //   ret = {\n  //     in: {\n  //       name: argv._[0],\n  //       createStream: () => fs.createReadStream(resolvedIn),\n  //       isDir: () => fs.lstatSync(argv._[0]).isDirectory(),\n  //       files: () => fs.lstatSync(resolvedIn).isDirectory() ? fs.readdirSync(resolvedIn, { withFileTypes: true }).filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1)))).map(dirrent => dirrent.name) : resolvedIn\n  //     },\n  //     out: { name: 'stdout', createStream: () => process.stdout, isDir: () => false },\n  //     override: argv.f\n  //   }\n  // } else {\n  //   debug('two or more arguments')\n\n  //   if (argv._[0] == '-') {\n  //     debug('first argument was - - using stdin')\n  //     ret.in = {\n  //       name: 'stdin',\n  //       createStream: () => process.stdin,\n  //       isDir: () => false\n  //     }\n  //     debug('Reading from stdin');\n  //   } else {\n  //     const resolvedIn = path.resolve(argv._[0])\n  //     debug(`first argument was ${argv._[0]}. Resolved is ${resolvedIn}`)\n  //     try {\n  //       fs.accessSync(resolvedIn, fs.constants.R_OK)\n\n  //       debug('fs.readdirSync(resolvedIn)=', fs.readdirSync(resolvedIn))\n\n  //       ret.in = {\n  //         name: resolvedIn,\n  //         createStream: () => fs.createReadStream(resolvedIn),\n  //         isDir: () => fs.lstatSync(resolvedIn).isDirectory(),\n  //         files: () => {\n  //           if (fs.lstatSync(resolvedIn).isDirectory()) {\n  //             return fs\n  //               .readdirSync(resolvedIn, { withFileTypes: true })\n  //               .filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1))))\n  //               .map(dirrent => {\n  //                 debug('dirrent.name=' + dirrent.name)\n  //                 debug('path.resolve(resolvedIn, dirrent.name)=' + path.resolve(resolvedIn, dirrent.name))\n  //                 return path.resolve(resolvedIn, dirrent.name)\n  //               }) \n  //            }\n  //            else {\n  //             return resolvedIn\n  //            }\n  //         }\n  //       }\n  //     } catch (e) {\n  //       if (e.hasOwnProperty('syscall'))\n  //         throw new Error(`Could not ${e.syscall} \"${e.path}\"`, { cause: e })\n  //       else\n  //         throw e;\n  //     }\n  //   }\n\n  //   if (argv._[1] == '-') {\n  //     debug('second argument was - - using stdout')\n  //     ret.out = {\n  //       name: 'stdout',\n  //       createStream: () => process.stdout,\n  //       isDir: () => false\n  //     }\n  //     debug('writing to stdout');\n  //   } else {\n\n  //     debug('argv._[1]=', argv._[1])\n  //     const dest = path.resolve(argv._[1]);\n  //     debug('dest=', dest)\n\n  //     if (argv._[1].endsWith(path.sep)) {\n  //       // handle out as directory\n        \n  //       // check if the directory exists\n  //       if (!directoryExists(dest)) {\n  //         createDirectory(dest)\n  //       }\n  //       ret.out = {\n  //         name: dest,\n  //         createStream: () => fs.createWriteStream(dest, { flags: 'w' }),\n  //         isDir: () => true\n  //       }\n  //     }\n  //     else {\n  //       // handleOutAsFile\n\n  //       const destDir = path.dirname(argv._[1]);\n\n  //       // check if the directory exists\n  //       if (!directoryExists(destDir)) {\n  //         createDirectory(destDir)\n  //       }\n  //       ret.out = {\n  //         name: argv._[1],\n  //         createStream: () => {\n  //           return fs.createWriteStream(dest, { flags: 'w' })\n  //         },\n  //         isDir: () => false\n  //       }\n\n  //     }\n  //   }\n  // }\n\n  // if (argv.hasOwnProperty('f')) {\n  //   ret.override = argv.f\n  // }\n  // if (argv.hasOwnProperty('allow-digits-to-start-css-classes')) {\n  //   ret.allowDigitToStartClassName = !!argv['allow-digits-to-start-css-classes']\n  //   debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n  // } else if (argv.hasOwnProperty('allowDigitToStartClassName')) {\n  //   ret.allowDigitToStartClassName = new Boolean(argv['allowDigitToStartClassName'])\n  //   debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n  // }\n\n  // return ret\n}\n\nexport default parseArguments"],"names":["$4226c92db7aa915b$var$debug","$bJOKe$debug","$4226c92db7aa915b$export$777d1004acb65c30","fileExtWithDot","toLowerCase","$4226c92db7aa915b$export$f7e9f41ea797a17","filename","$bJOKe$fs","accessSync","e","$4226c92db7aa915b$export$af6bad00634a71e4","originalDir","process","cwd","notFound","constants","F_OK","chdir","pkgDir","Array","prototype","peek","this","length","String","removeFromEnd","str","endsWith","substring","lastIndexOf","toString","$b1ddc3f21e90a87c$var$debug","$b1ddc3f21e90a87c$var$shouldExit","$b1ddc3f21e90a87c$export$2e2bcd8739ae039","processOrArgv","printUsage","options","undefined","optional","requiredParams","required","ret","args","processOrNot","startsWith","hasOwnProperty","nodePath","program","slice","argv","includes","exit","internalOptions","internalArgs","i","element","key","val","split","push","Object","keys","reqIdx","aliases","concat","name","forEach","requiredName","some","ref","ref1","ref2","ref3","contains","Error"],"version":3,"file":"index.js.map","sourceRoot":"../../../"}