{"mappings":"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","sources":["workspaces/utils/src/utils.js","workspaces/utils/src/parse_arguments.js","workspaces/utils/src/decorate_args.js","workspaces/utils/src/index.js"],"sourcesContent":["import debugFunc from 'debug'\nimport fs from 'fs'\n\nconst debug = debugFunc('@foo-dog:utils')\n\nfunction isSupportedFileExtension(fileExtWithDot) {\n  return fileExtWithDot.toLowerCase() == '.pug' || fileExtWithDot.toLowerCase() == '.foo-dog'\n}\n\nArray.prototype.peek = function () {\n  return this[this.length - 1]\n}\n\nString.prototype.removeFromEnd = function (str) {\n  return this.endsWith(str) ? this.substring(0, this.lastIndexOf(str)) : this.toString()\n}\n\nfunction exists(filename) {\n  try {\n    return (fs.accessSync(filename), true)\n  } catch (e) {\n    return false\n  }\n}\n\nfunction directoryExists(dir) {\n  try {\n    // fs.lstatSync(destFileToWriteTo)\n    fs.accessSync(dir, fs.constants.R_OK)\n    return true\n  } catch (e) { }\n  return false\n}\n\nfunction createDirectory(dir) {\n  fs.mkdirSync(dir, { recursive: true });\n}\n\n// /**\n//  * @param process Node process (TODO: pass in arguments only)\n//  * @param printUsage function\n//  */\n// // This isn't fully flushed out yet\n// async function parseArguments(process, printUsage) {\n//   const argv = minimist(process.argv.slice(2))\n//   // debug('argv=', argv)\n\n\n  \n//   let ret = { in: {}, out: {} }\n\n//   if (argv.help || argv.h) {\n//     debug('help option detected')\n//     if (printUsage != undefined && typeof printUsage === 'function') {\n//       printUsage()\n//     }\n//     else {\n//       console.log('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n//     }\n//     process.exit()\n//   } else if (argv._.length == 0) {\n//     debug('no arguments - using stdin and stdout')\n//     ret = { \n//       in: { \n//         name: 'stdin', \n//         createStream: () => process.stdin, \n//         isDir: () => false \n//       }, \n//       out: { \n//         name: 'stdout', \n//         createStream: () => process.stdout, \n//         isDir: () => false\n//       }\n//     }\n//   } else if (argv._.length == 1) {\n//     debug('one argument - reading file and piping to stdout')\n//     try {\n//       fs.accessSync(argv._[0], fs.constants.R_OK)\n//     } catch (e) {\n//       throw new Error(`Could not ${e.syscall} \"${e.path}\"`)\n//     }\n\n//     // debug('creating read stream for ' + argv?._[0])\n//     const resolvedIn = path.resolve(argv._[0])\n\n//     ret = {\n//       in: {\n//         name: argv._[0],\n//         createStream: () => fs.createReadStream(resolvedIn),\n//         isDir: () => fs.lstatSync(argv._[0]).isDirectory(),\n//         files: () => fs.lstatSync(resolvedIn).isDirectory() ? fs.readdirSync(resolvedIn, { withFileTypes: true }).filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1)))).map(dirrent => dirrent.name) : resolvedIn\n//       },\n//       out: { name: 'stdout', createStream: () => process.stdout, isDir: () => false },\n//       override: argv.f\n//     }\n//   } else {\n//     debug('two or more arguments')\n\n//     if (argv._[0] == '-') {\n//       debug('first argument was - - using stdin')\n//       ret.in = {\n//         name: 'stdin',\n//         createStream: () => process.stdin,\n//         isDir: () => false\n//       }\n//       debug('Reading from stdin');\n//     } else {\n//       const resolvedIn = path.resolve(argv._[0])\n//       debug(`first argument was ${argv._[0]}. Resolved is ${resolvedIn}`)\n//       try {\n//         fs.accessSync(resolvedIn, fs.constants.R_OK)\n\n//         debug('fs.readdirSync(resolvedIn)=', fs.readdirSync(resolvedIn))\n\n//         ret.in = {\n//           name: resolvedIn,\n//           createStream: () => fs.createReadStream(resolvedIn),\n//           isDir: () => fs.lstatSync(resolvedIn).isDirectory(),\n//           files: () => {\n//             if (fs.lstatSync(resolvedIn).isDirectory()) {\n//               return fs\n//                 .readdirSync(resolvedIn, { withFileTypes: true })\n//                 .filter(dirent => dirent.isFile() && isSupportedFileExtension(path.extname(dirent.name.slice(1))))\n//                 .map(dirrent => {\n//                   debug('dirrent.name=' + dirrent.name)\n//                   debug('path.resolve(resolvedIn, dirrent.name)=' + path.resolve(resolvedIn, dirrent.name))\n//                   return path.resolve(resolvedIn, dirrent.name)\n//                 }) \n//              }\n//              else {\n//               return resolvedIn\n//              }\n//           }\n//         }\n//       } catch (e) {\n//         if (e.hasOwnProperty('syscall'))\n//           throw new Error(`Could not ${e.syscall} \"${e.path}\"`, { cause: e })\n//         else\n//           throw e;\n//       }\n//     }\n\n//     if (argv._[1] == '-') {\n//       debug('second argument was - - using stdout')\n//       ret.out = {\n//         name: 'stdout',\n//         createStream: () => process.stdout,\n//         isDir: () => false\n//       }\n//       debug('writing to stdout');\n//     } else {\n\n//       debug('argv._[1]=', argv._[1])\n//       const dest = path.resolve(argv._[1]);\n//       debug('dest=', dest)\n\n//       if (argv._[1].endsWith(path.sep)) {\n//         // handle out as directory\n        \n//         // check if the directory exists\n//         if (!directoryExists(dest)) {\n//           createDirectory(dest)\n//         }\n//         ret.out = {\n//           name: dest,\n//           createStream: () => fs.createWriteStream(dest, { flags: 'w' }),\n//           isDir: () => true\n//         }\n//       }\n//       else {\n//         // handleOutAsFile\n\n//         const destDir = path.dirname(argv._[1]);\n\n//         // check if the directory exists\n//         if (!directoryExists(destDir)) {\n//           createDirectory(destDir)\n//         }\n//         ret.out = {\n//           name: argv._[1],\n//           createStream: () => {\n//             return fs.createWriteStream(dest, { flags: 'w' })\n//           },\n//           isDir: () => false\n//         }\n\n//       }\n//     }\n//   }\n\n//   if (argv.hasOwnProperty('f')) {\n//     ret.override = argv.f\n//   }\n//   if (argv.hasOwnProperty('allow-digits-to-start-css-classes')) {\n//     ret.allowDigitToStartClassName = !!argv['allow-digits-to-start-css-classes']\n//     debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n//   } else if (argv.hasOwnProperty('allowDigitToStartClassName')) {\n//     ret.allowDigitToStartClassName = new Boolean(argv['allowDigitToStartClassName'])\n//     debug('ret.allowDigitToStartClassName=', ret.allowDigitToStartClassName)\n//   }\n\n//   return ret\n// }\n\nfunction simpleProjectRootDir() {\n  const originalDir = process.cwd()\n  let notFound = true\n  while (notFound) {\n    try {\n      fs.accessSync('package.json', fs.constants.F_OK)\n      notFound = false\n    } catch (e) {\n      process.chdir('..')\n    }\n  }\n  const pkgDir = process.cwd()\n  process.chdir(originalDir)\n  return pkgDir\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  directoryExists,\n  createDirectory,\n  simpleProjectRootDir\n}","import debugFunc from 'debug'\nconst debug = debugFunc('@foo-dog/utils:parse_arguments')\n\nfunction isNodeProcess(processOrArgv) {\n  debug('processOrArgv=', processOrArgv)\n\n  return (\n    typeof processOrArgv === 'object' &&\n    processOrArgv.hasOwnProperty('argv') &&\n    processOrArgv.argv[0].startsWith('/') &&\n    processOrArgv.title.endsWith('node')\n  )\n}\n\nfunction checkForRequiredParameters(requiredParams, argumentsAndOptions) {\n  requiredParams.forEach(requiredParameter => {\n    checkForRequiredParam(requiredParameter, argumentsAndOptions)\n  })\n}\n\nfunction checkForRequiredParam(requiredParameter, argumentsAndOptions) {\n  const nameAndAliases = createNameAndAliasesArray(requiredParameter)\n\n  const argumentsHasNameOrAlias = doArgumentsOrOptionsHaveNameOrAlias(nameAndAliases, argumentsAndOptions)\n\n  if (!argumentsHasNameOrAlias) {\n    throw new Error('Required field \"' + requiredParameter.name + '\" was not found')\n  }\n}\n\nfunction createNameAndAliasesArray(requiredParameter) {\n  let nameAndAliases = [requiredParameter.name]\n  if (requiredParameter.aliases) {\n    nameAndAliases = nameAndAliases.concat(requiredParameter.aliases)\n  }\n  return nameAndAliases\n}\n\n/**\n * @returns boolean\n */\nfunction doArgumentsOrOptionsHaveNameOrAlias(nameAndAliases, argumentsAndOptions) {\n  return (\n    checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.args) ||\n    checkCollectionForNameOrAlias(nameAndAliases, argumentsAndOptions.options)\n  )\n}\n\nfunction checkCollectionForNameOrAlias(nameAndAliases, parameterCollection) {\n  let argumentsHaveNameOrAlias = false\n\n  debug('nameAndAliases=', nameAndAliases)\n  debug('parameterCollection=', parameterCollection)\n\n  if (parameterCollection != undefined) {\n    if (Array.isArray(parameterCollection) && parameterCollection.length) {\n      argumentsHaveNameOrAlias = nameAndAliases.some(name => parameterCollection.includes(name))\n    } else if (typeof parameterCollection === 'object') {\n      argumentsHaveNameOrAlias = nameAndAliases.some(name => parameterCollection.hasOwnProperty(name))\n    } else {\n      console.error(\n        'Unexpected error in checkCollectionForNameOrAlias(). nameAndAliases=',\n        nameAndAliases,\n        ', parameterCollection=',\n        parameterCollection\n      )\n      throw new Error('Unexpected error (and nothing coded to handle it)')\n    }\n  }\n  return argumentsHaveNameOrAlias\n}\n\n/**\n * @param processOrArgv A Node process or an array of command line parameters\n * @param printUsage The function to print when \"-h\" or \"--help\" is a parameter\n * @param options optional and required parameters:\n *        {\n *          optional: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ],\n *          required: [\n *            {\n *              name: '',\n *              aliases: []\n *            }\n *          ]\n *        }\n */\n// This isn't fully flushed out yet\nasync function parseArguments(processOrArgv, printUsage, options) {\n  if (options == undefined) {\n    options = typeof printUsage === 'object' ? printUsage : {}\n  }\n\n  const optionalParams = options.optional ?? []\n  const requiredParams = options.required ?? []\n\n  debug('optional parameters=', optionalParams)\n  debug('required parameters=', requiredParams)\n\n  const ret = {}\n  let args\n  if (isNodeProcess(processOrArgv)) {\n    ret.nodePath = processOrArgv.argv[0]\n    ret.program = processOrArgv.argv[1]\n    args = processOrArgv.argv.slice(2)\n  } else {\n    args = processOrArgv?.argv || processOrArgv\n  }\n\n  if (args.includes('-h') || args.includes('--help')) {\n    if (printUsage != undefined && typeof printUsage === 'function') {\n      printUsage()\n    } else {\n      debug('No help available. Please contact the developer, which is probably Adam Koch, and tell him he is missing the help.')\n    }\n  } else {\n    const internalOptions = {},\n      internalArgs = []\n\n    args.forEach(element => {\n      if (element === '-') {\n        internalArgs.push(element)\n      } else if (element.startsWith('--')) {\n        const [key, val] = element.split('=')\n        internalOptions[key.slice(2)] = val || true\n      } else if (element.startsWith('-')) {\n        const [key, val] = element.split('=')\n        internalOptions[key.slice(1)] = val || true\n      } else {\n        internalArgs.push(element)\n      }\n    })\n\n    if (internalArgs.length > 0) {\n      ret.args = internalArgs\n    }\n\n    if (Object.keys(internalOptions).length > 0) {\n      ret.options = internalOptions\n    }\n\n    checkForRequiredParameters(requiredParams, ret)\n\n    return ret\n  }\n\n}\n\nexport default parseArguments\n","import path from 'node:path'\nimport fs from 'fs'\nimport { readdirSync } from 'node:fs'\n\nfunction createReadCreateStreamFunc(filename) {\n  try {\n    fs.statSync(filename)\n    return () => fs.createReadStream(filename)\n  }\n  catch (e) {\n    if (e.message == \"ENOENT: no such file or directory, stat '\" + filename + \"'\")\n      return () => { throw new Error('file not found') }\n    else\n      throw e\n  }\n}\n\nfunction isWritableDirectory(dir) {\n  try {\n    if (fs.statSync(dir).isDirectory()) {\n      fs.accessSync(dir, fs.constants.R_OK | fs.constants.W_OK)\n      return true\n    }\n    return false\n  }\n  catch (e) {\n    if (e.code === 'ENOTDIR' || e.code === 'ENOENT')\n      return false\n\n    console.error(\"Error testing if \" + dir + \" is a directory. Error: \" + e.message)\n    throw e\n  }\n}\n\nfunction handleDirection(options, direction, directoryFunction) {\n  if (options[direction]?.name) {\n    const resolvedName = path.resolve(options[direction].name)\n    if (isWritableDirectory(resolvedName)) {\n      options[direction].isDir = () => true\n      directoryFunction(options)\n    }\n    else {\n      options[direction].isDir = () => false\n      if (direction === 'in') {\n        options[direction].createStream = createReadCreateStreamFunc(resolvedName)\n      }\n    }\n    options[direction].name = options[direction]?.name === 'stdin' || options[direction]?.name === 'stdout' ? options[direction]?.name : resolvedName\n  }\n}\n\nexport default {\n  withCreateStreams(options) {\n    handleDirection(options, 'in', function(options) {\n      options.in.files = readdirSync(options.in.name)\n    })\n    handleDirection(options, 'out', function(options) {\n      // If we are in here, out.name ends with a path separator\n      const dirName = path.resolve(options.out.name)\n      options.out.name = path.resolve(dirName, path.parse(options.in.name).name)\n      try {\n        fs.statSync(options.out.name)\n        options.out.createStream = () => fs.createWriteStream(options.out.name)\n      }\n      catch (e) {\n        console.error('Could not find directory: ' + dirName + ' or write ' + options.out.name + ': ' + e.message)\n        if (e.message == \"ENOENT: no such file or directory, stat '\" + dirName + \"'\")\n          return () => { throw new Error('file not found') }\n        else\n          throw e\n      }\n    })\n    return options\n  }\n}\n","import {\n  isSupportedFileExtension,\n  simpleProjectRootDir,\n  exists\n} from '../src/utils.js'\nimport originalParseArguments from '../src/parse_arguments.js'\nimport decorateArgs from '../src/decorate_args.js'\n\nfunction defined(obj) {\n  return obj != null && obj != undefined\n}\n\nfunction existsLength(obj, keyForArray) {\n  return defined(obj) && defined(obj[keyForArray]) && Array.isArray(obj[keyForArray]) ? obj[keyForArray].length : -1\n}\n\nfunction defaultInName(obj) {\n  return existsLength(obj, 'args') > 0 ? obj.args[0] : 'stdin'\n}\n\nfunction defaultOutName(obj) {\n  return existsLength(obj, 'args') > 1 ? obj.args[1] : 'stdout'\n}\n\nconst parseArguments = async (...arr) => {\n  const parsedArgs = await originalParseArguments(...arr)\n  const newArgs = {...parsedArgs}\n  newArgs.in = { name: defaultInName(parsedArgs) }\n  newArgs.out = { name: defaultOutName(parsedArgs) }\n  return decorateArgs.withCreateStreams(newArgs)\n}\n\nexport {\n  exists,\n  isSupportedFileExtension,\n  parseArguments,\n  simpleProjectRootDir\n}"],"names":["$bJOKe$debug","$4226c92db7aa915b$export$777d1004acb65c30","fileExtWithDot","toLowerCase","$4226c92db7aa915b$export$f7e9f41ea797a17","filename","$bJOKe$fs","accessSync","e","$4226c92db7aa915b$export$af6bad00634a71e4","originalDir","process","cwd","notFound","constants","F_OK","chdir","pkgDir","Array","prototype","peek","this","length","String","removeFromEnd","str","endsWith","substring","lastIndexOf","toString","$b1ddc3f21e90a87c$var$debug","$b1ddc3f21e90a87c$var$checkForRequiredParameters","requiredParams","argumentsAndOptions","forEach","requiredParameter","nameAndAliases","name","aliases","concat","$b1ddc3f21e90a87c$var$createNameAndAliasesArray","$b1ddc3f21e90a87c$var$checkCollectionForNameOrAlias","args","options","$b1ddc3f21e90a87c$var$doArgumentsOrOptionsHaveNameOrAlias","Error","$b1ddc3f21e90a87c$var$checkForRequiredParam","parameterCollection","argumentsHaveNameOrAlias","undefined","isArray","some","includes","console","error","hasOwnProperty","$b1ddc3f21e90a87c$export$2e2bcd8739ae039","processOrArgv","printUsage","optionalParams","optional","required","ret","argv","startsWith","title","$b1ddc3f21e90a87c$var$isNodeProcess","nodePath","program","slice","internalOptions","internalArgs","element","push","key","val","split","Object","keys","$6e43e11cccfc60f7$var$handleDirection","direction","directoryFunction","ref","ref1","ref2","ref3","resolvedName","$bJOKe$nodepath","resolve","dir","statSync","isDirectory","R_OK","W_OK","code","message","$6e43e11cccfc60f7$var$isWritableDirectory","isDir","createStream","createReadStream","$6e43e11cccfc60f7$var$createReadCreateStreamFunc","$6e43e11cccfc60f7$export$2e2bcd8739ae039","withCreateStreams","options1","in","files","$bJOKe$readdirSync","dirName","out","parse","createWriteStream","$fdeccbe171b4469a$var$defined","obj","$fdeccbe171b4469a$var$existsLength","keyForArray","$fdeccbe171b4469a$var$defaultOutName","$fdeccbe171b4469a$export$63c5b6d6ff5b7ee1","async","arr","parsedArgs","newArgs"],"version":3,"file":"index.js.map","sourceRoot":"../../../"}